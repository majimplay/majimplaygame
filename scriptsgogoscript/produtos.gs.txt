// --- CONFIGURAÇÕES GLOBAIS ---
// ** Certifique-se de que o SPREADSHEET_ID está correto **
const SPREADSHEET_ID = '1EYUPZjfdnPJz9tI9yJFN1cVoiy9Fs3HABqFZFaz4r2A'; // Substitua pelo ID da sua planilha

// Nomes das abas
const SHEET_NAME_PRODUTOS = 'Produtos'; // Nome da aba onde estão os produtos
const SHEET_NAME_CLIENTES = 'Clientes'; // Nome da aba onde estão os clientes (usado na função doGet original)
const SHEET_NAME_LOJA = 'Loja'; // Nova aba para lojas
// Nomes das colunas
const PRODUCT_ID_COLUMN_NAME = 'ID_PRODUTO'; // Nome da coluna do ID do Produto
const GOGOID_COLUMN_NAME = 'GOGOID'; // Nome da coluna do Google ID do usuário associado aos produtos
const GOOGLE_ID_COLUMN_NAME_CLIENTES = 'GoogleUserId'; // Nome da coluna do Google ID na aba de clientes (ajuste se for diferente)
// Nomes das colunas na aba "Loja"
const LOJA_GOGOID_COLUMN_NAME = 'ID'; // Coluna com o ID da loja (deve corresponder ao GOGOID dos produtos)
const LOJA_PRODUTOS_COLUMN_NAME = 'Produtos Da Loja'; // Coluna que armazena os IDs dos produtos
const LOJA_NAME_COLUMN_NAME = 'loja'; //  nome da loja 
const LOJA_REPUTACAO_COLUMN_NAME = 'REPUTACAO';
const PRODUCT_ATTRIBUTES_MAP = {
  'NOME': 'NOME',
  'PRECO': 'PRECO',
  'PESO': 'PESO',
  'ALTURA': 'ALTURA',
  'LARGURA': 'LARGURA',
  'COMPRIMENTO': 'COMPRIMENTO',
  'IMAGENS': 'IMAGENS'
};

// Mapeamento para a função doGet de clientes (ajuste conforme a sua planilha de clientes)
const FIELD_TO_COLUMN_MAP_CLIENTES = {
  'googleUserId': GOOGLE_ID_COLUMN_NAME_CLIENTES,
  'nome': 'Nome', // Exemplo: mapeia o campo 'nome' para a coluna 'Nome'
  'email': 'Email' // Exemplo: mapeia o campo 'email' para a coluna 'Email'
  // Adicione outros mapeamentos conforme as colunas da sua aba de clientes
};

// --- FIM DAS CONFIGURAÇÕES GLOBAIS ---


// ========================================================================
// FUNÇÕES AUXILIARES (Podem ser usadas por diferentes funções doGet/doPost)
// ========================================================================

function getHeaders(sheet) {
  if (sheet.getLastRow() === 0) throw new Error("Planilha vazia");
  const headerRow = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const headers = headerRow.map(String).map(h => h.trim());

  // Validação básica para garantir que colunas essenciais existam
  // Dependendo da função que chama getHeaders, pode ser necessário validar colunas diferentes
  // Esta validação é mais relevante para as funções doPost/addProduct/editProduct/deleteProduct
  // que operam na aba de Produtos.
  // if (!headers.includes(PRODUCT_ID_COLUMN_NAME)) throw new Error(`Coluna ${PRODUCT_ID_COLUMN_NAME} faltando`);
  // if (!headers.includes(GOGOID_COLUMN_NAME)) throw new Error(`Coluna ${GOGOID_COLUMN_NAME} faltando`);

  return headers;
}

function rowToObject(rowArray, headers) {
  return headers.reduce((obj, header, index) => {
    if (header) obj[header] = rowArray[index];
    return obj;
  }, {});
}

// Função auxiliar para mapear dados de um objeto para uma linha (usada no doPost)
function mapProductDataToRow(productData, headers, productId, gogoId) {
  const newRow = Array(headers.length).fill('');
  const pidIndex = headers.indexOf(PRODUCT_ID_COLUMN_NAME);
  const gidIndex = headers.indexOf(GOGOID_COLUMN_NAME);
  if (pidIndex > -1) newRow[pidIndex] = productId;
  if (gidIndex > -1) newRow[gidIndex] = gogoId;

  Object.entries(PRODUCT_ATTRIBUTES_MAP).forEach(([jsonKey, colName]) => {
    const colIndex = headers.indexOf(colName);
    if (colIndex > -1 && productData[jsonKey] !== undefined) {
      newRow[colIndex] = productData[jsonKey];
    }
  });
  return newRow;
}

// Função auxiliar para encontrar uma linha pelo ID do produto (usada no doPost e doGetProductById)
function findRowByProductId(sheet, headers, productId) {
  const pidIndex = headers.indexOf(PRODUCT_ID_COLUMN_NAME);
  if (pidIndex === -1) {
      Logger.log(`[findRowByProductId] Erro: Coluna "${PRODUCT_ID_COLUMN_NAME}" não encontrada nos cabeçalhos.`);
      return null; // Não pode encontrar se a coluna de ID não existe
  }

  const data = sheet.getDataRange().getValues();

  // Começa do índice 1 para pular o cabeçalho
  for (let i = 1; i < data.length; i++) {
    // Compara o valor na coluna do ID do produto com o ID buscado
    if (String(data[i][pidIndex]).trim() === String(productId).trim()) {
      return { rowIndex: i + 1, rowData: data[i] }; // Retorna o índice da linha na planilha (base 1) e os dados
    }
  }
  return null; // Retorna null se não encontrar
}
//função auxiliar para atualizar a loja:
function updateLojaProducts(sheetLoja, gogoid, newProductId) {
  const headers = getHeaders(sheetLoja);
  const gogoidIndex = headers.indexOf(LOJA_GOGOID_COLUMN_NAME);
  const produtosIndex = headers.indexOf(LOJA_PRODUTOS_COLUMN_NAME);

  if (gogoidIndex === -1 || produtosIndex === -1) {
    throw new Error(`Colunas essenciais não encontradas na aba "${SHEET_NAME_LOJA}"`);
  }

  const data = sheetLoja.getDataRange().getValues();
  let lojaEncontrada = false;

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][gogoidIndex]).trim() === String(gogoid).trim()) {
      const currentProducts = data[i][produtosIndex] ? String(data[i][produtosIndex]).split(',') : [];
      currentProducts.push(newProductId);
      sheetLoja.getRange(i + 1, produtosIndex + 1).setValue(currentProducts.join(','));
      lojaEncontrada = true;
      break;
    }
  }

  if (!lojaEncontrada) {
    throw new Error(`Loja com ${LOJA_GOGOID_COLUMN_NAME} = "${gogoid}" não encontrada.`);
  }
}

function addProduct(sheet, headers, requestData) {
  const productData = requestData.productData || {};
  if (!productData.GOGOID) throw new Error("GOGOID obrigatório para adicionar produto");

  // --- VALIDAÇÃO DA LOJA ---
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheetLoja = ss.getSheetByName(SHEET_NAME_LOJA);
  
  // Se a aba "Loja" não existir, interrompe
  if (!sheetLoja) {
    throw new Error(`A aba "${SHEET_NAME_LOJA}" não foi encontrada. Produto não adicionado.`);
  }

  // Valida colunas essenciais da aba "Loja"
  const lojaHeaders = getHeaders(sheetLoja);
  if (
    !lojaHeaders.includes(LOJA_GOGOID_COLUMN_NAME) || 
    !lojaHeaders.includes(LOJA_NAME_COLUMN_NAME) || 
    !lojaHeaders.includes(LOJA_PRODUTOS_COLUMN_NAME)
  ) {
    throw new Error(`Colunas obrigatórias não encontradas na aba "${SHEET_NAME_LOJA}".`);
  }

  // Busca a loja pelo GOGOID e valida o nome
  const lojaData = sheetLoja.getDataRange().getValues();
  const gogoidIndex = lojaHeaders.indexOf(LOJA_GOGOID_COLUMN_NAME);
  const nomeLojaIndex = lojaHeaders.indexOf(LOJA_NAME_COLUMN_NAME);
  
  let lojaEncontrada = false;
  let nomeLoja = '';

  for (let i = 1; i < lojaData.length; i++) {
    if (String(lojaData[i][gogoidIndex]).trim() === String(productData.GOGOID).trim()) {
      nomeLoja = lojaData[i][nomeLojaIndex];
      lojaEncontrada = true;
      break;
    }
  }

  // Se a loja não existir ou o nome estiver vazio, interrompe
  if (!lojaEncontrada) {
    throw new Error(`Loja com ${LOJA_GOGOID_COLUMN_NAME} = "${productData.GOGOID}" não encontrada.`);
  }
  if (!nomeLoja || nomeLoja.toString().trim() === '') {
    throw new Error(`Nome da loja está vazio para o GOGOID ${productData.GOGOID}.`);
  }

  // --- ADICIONA O PRODUTO SE TUDO ESTIVER VÁLIDO ---
  const newProductId = Utilities.getUuid();
  const newRow = mapProductDataToRow(productData, headers, newProductId, productData.GOGOID);
  sheet.appendRow(newRow);

  // Atualiza a lista de produtos da loja
  updateLojaProducts(sheetLoja, productData.GOGOID, newProductId);

  return {
    status: 'success',
    message: 'Produto adicionado e loja validada',
    productId: newProductId,
    addedData: rowToObject(newRow, headers),
    lojaNome: nomeLoja // Retorna o nome da loja para confirmação
  };
}
// ========================================================================
// FUNÇÕES doPost (do seu script original de produtos)
// ========================================================================

function doPost(e) {
  let responsePayload = {};
  try {
    if (!e?.postData?.contents) throw new Error("Requisição inválida");
    const requestData = JSON.parse(e.postData.contents);
    const action = requestData.action?.toLowerCase();

    if (!action) throw new Error("Propriedade 'action' obrigatória");

    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAME_PRODUTOS); // Usa o nome da aba de produtos
    if (!sheet) throw new Error(`Aba "${SHEET_NAME_PRODUTOS}" não encontrada`);

    const headers = getHeaders(sheet);

    // Verifica se as colunas obrigatórias para POST de produtos existem
    if (!headers.includes(PRODUCT_ID_COLUMN_NAME)) throw new Error(`Coluna ${PRODUCT_ID_COLUMN_NAME} faltando na aba ${SHEET_NAME_PRODUTOS}`);
    if (!headers.includes(GOGOID_COLUMN_NAME)) throw new Error(`Coluna ${GOGOID_COLUMN_NAME} faltando na aba ${SHEET_NAME_PRODUTOS}`);


    switch (action) {
      case 'add':
        responsePayload = addProduct(sheet, headers, requestData);
        break;
      case 'edit':
        responsePayload = editProduct(sheet, headers, requestData);
        break;
      case 'delete':
        responsePayload = deleteProduct(sheet, headers, requestData);
        break;
      default:
        throw new Error(`Ação "${action}" não suportada para POST em produtos`);
    }

  } catch (error) {
    Logger.log(`ERRO em doPost (Produtos): ${error.message}`);
    responsePayload = { status: 'error', message: error.message };
  }

  return ContentService.createTextOutput(JSON.stringify(responsePayload))
    .setMimeType(ContentService.MimeType.JSON);
}
// Funções addProduct, editProduct, deleteProduct (mantidas do seu script original)
function addProduct(sheet, headers, requestData) {
  const productData = requestData.productData || {};
  if (!productData.GOGOID) throw new Error("GOGOID obrigatório para adicionar produto");

  // --- VERIFICAÇÃO DA LOJA ANTES DE ADICIONAR O PRODUTO ---
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheetLoja = ss.getSheetByName(SHEET_NAME_LOJA);
  
  // Se a aba "Loja" não existir, interrompe imediatamente
  if (!sheetLoja) {
    throw new Error(`A aba "${SHEET_NAME_LOJA}" não foi encontrada. Produto não adicionado.`);
  }

  // Valida colunas essenciais da aba "Loja"
  const lojaHeaders = getHeaders(sheetLoja);
  if (!lojaHeaders.includes(LOJA_GOGOID_COLUMN_NAME) || !lojaHeaders.includes(LOJA_NAME_COLUMN_NAME)) {
    throw new Error(`Colunas obrigatórias (${LOJA_GOGOID_COLUMN_NAME} ou ${LOJA_NAME_COLUMN_NAME}) não encontradas na aba "${SHEET_NAME_LOJA}".`);
  }

  // --- CRIA O PRODUTO SÓ SE A LOJA FOR VÁLIDA ---
  const newProductId = Utilities.getUuid();
  const newRow = mapProductDataToRow(productData, headers, newProductId, productData.GOGOID);
  
  // Tenta atualizar a loja (se falhar, o erro propagará e interromperá a execução)
  updateLojaProducts(sheetLoja, productData.GOGOID, newProductId); // ⚠️ Pode lançar erro
  
  // Se chegou aqui, a loja foi atualizada. Adiciona o produto.
  sheet.appendRow(newRow);

  return {
    status: 'success',
    message: 'Produto adicionado e loja atualizada',
    productId: newProductId,
    addedData: rowToObject(newRow, headers)
  };
}

function editProduct(sheet, headers, requestData) {
  const productId = requestData.PRODUCT_ID || requestData.productData?.[PRODUCT_ID_COLUMN_NAME];
  if (!productId) throw new Error("ID do produto obrigatório para editar");

  const foundRowInfo = findRowByProductId(sheet, headers, productId); // Usa a função auxiliar
  if (!foundRowInfo) throw new Error("Produto não encontrado para edição");

  const { rowIndex, rowData } = foundRowInfo;
  const updatedRow = [...rowData];
  let changesMade = false;

  Object.entries(requestData.productData || {}).forEach(([key, value]) => {
    // Determina o nome da coluna correspondente
    const colName = [PRODUCT_ID_COLUMN_NAME, GOGOID_COLUMN_NAME].includes(key) ? key :
                    PRODUCT_ATTRIBUTES_MAP[key] || (headers.includes(key) ? key : null);

    if (!colName) return; // Ignora chaves que não correspondem a nenhuma coluna mapeada ou cabeçalho
    const colIndex = headers.indexOf(colName);
    if (colIndex === -1) return; // Ignora se a coluna não existe na planilha

    // Evita a edição direta de ID_PRODUTO e GOGOID via edit action, a menos que seja estritamente necessário e controlado
    if ([PRODUCT_ID_COLUMN_NAME, GOGOID_COLUMN_NAME].includes(colName)) {
       // Opcional: logar ou lançar erro se tentar mudar ID ou GOGOID aqui
       if (String(value) !== String(updatedRow[colIndex])) {
          Logger.log(`Aviso: Tentativa de alterar campo protegido "${colName}" para "${value}" no produto ${productId}. Ignorado.`);
       }
       return; // Não permite alteração destes campos por esta via
    }

    // Compara e atualiza se o valor for diferente
    if (String(updatedRow[colIndex]) !== String(value)) {
      updatedRow[colIndex] = value;
      changesMade = true;
    }
  });

  if (!changesMade) {
    return {
      status: 'info',
      message: 'Nenhuma alteração detectada',
      productId: productId
    };
  }

  // Atualiza a linha na planilha
  sheet.getRange(rowIndex, 1, 1, updatedRow.length).setValues([updatedRow]);

  return {
    status: 'success',
    message: 'Produto atualizado',
    productId: productId,
    updatedData: rowToObject(updatedRow, headers)
  };
}

function deleteProduct(sheet, headers, requestData) {
  const productId = requestData.PRODUCT_ID;
  if (!productId) throw new Error("ID do produto obrigatório para excluir");

  const foundRowInfo = findRowByProductId(sheet, headers, productId); // Usa a função auxiliar
  if (!foundRowInfo) throw new Error("Produto não encontrado para exclusão");

  const { rowIndex } = foundRowInfo;

  sheet.deleteRow(rowIndex); // Exclui a linha encontrada
  return {
    status: 'success',
    message: 'Produto excluído',
    productId: productId
  };
}


// ========================================================================
// FUNÇÃO doGet (principal) - Roteia requisições GET
// Esta função recebe todas as requisições GET e as direciona
// para as funções específicas com base no parâmetro 'action'.
// Se nenhum 'action' for especificado, pode executar uma ação padrão
// (como buscar dados do cliente, se for o caso).
// ========================================================================
function doGet(e) {
  let responsePayload = {};

  try {
    // Parâmetro 'action' para determinar qual operação GET executar
    const action = e?.parameter?.action?.toLowerCase();
    Logger.log(`[doGet Principal] Requisição recebida com action: ${action}`);

    if (action === 'getprodutosdaloja') {
      
      responsePayload = doGetProdutosDaLoja(e);
      return responsePayload;
    } else if (action === 'getproductbyid') {
      // Chama a função para buscar um produto por ID
      responsePayload = doGetProductById(e);

    } else if (action === 'gettodosprodutosordenadosporreputacao') {
      // Chama a função para buscar um produto por ID
      responsePayload = doGetTodosProdutosOrdenadosPorReputacao(e);

    } else {
      // Ação padrão se nenhum 'action' for especificado ou for desconhecido
      // Neste exemplo, vamos assumir que a ação padrão é buscar dados do cliente
      // Se você não tiver uma aba de clientes ou não quiser essa funcionalidade aqui,
      // remova ou ajuste esta parte.
       Logger.log("[doGet Principal] Nenhuma action especificada ou desconhecida. Executando doGet de cliente (padrão).");
       responsePayload = doGetCliente(e); // Chama a função original de doGet para clientes
    }

  } catch (error) {
    Logger.log(`[doGet Principal] Erro: ${error.message}\nParâmetros recebidos: ${JSON.stringify(e?.parameter)}\nStack: ${error.stack}`);
    responsePayload = {
      status: 'error',
      message: `Erro na requisição GET: ${error.message}`,
    };
  }

  // Retorna a resposta sempre em formato JSON
  return ContentService.createTextOutput(JSON.stringify(responsePayload))
    .setMimeType(ContentService.MimeType.JSON);
}


// ========================================================================
// FUNÇÃO doGetCliente (do seu script original de cliente)
// Usada para buscar dados de um cliente pelo Google ID na aba de Clientes
// Esta função é chamada pela função doGet principal quando action não é especificada
// ou é diferente das ações de produto.
// ========================================================================
function doGetCliente(e) {
  let responsePayload = {}; // Objeto para a resposta JSON
  let ss, sheet, headers, data, googleIdToSearch;

  try {
    // 1. Valida se o parâmetro 'googleUserId' foi passado na URL
    if (!e || !e.parameter || !e.parameter.googleUserId) {
      throw new Error("Parâmetro 'googleUserId' não fornecido na requisição GET de cliente.");
    }
    googleIdToSearch = e.parameter.googleUserId;
    Logger.log(`[doGet Cliente] Buscando dados para Google ID: ${googleIdToSearch}`);

    // 2. Acessa a planilha e a aba de Clientes
    ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    sheet = ss.getSheetByName(SHEET_NAME_CLIENTES); // Usa o nome da aba de clientes
    if (!sheet) {
      throw new Error(`Aba "${SHEET_NAME_CLIENTES}" não encontrada.`);
    }

    // 3. Lê os cabeçalhos e todos os dados da planilha
    data = sheet.getDataRange().getValues();
    // Verifica se há pelo menos a linha de cabeçalho E uma linha de dados
    if (data.length < 2) {
        Logger.log(`[doGet Cliente] Planilha "${SHEET_NAME_CLIENTES}" vazia ou sem dados (apenas cabeçalho).`);
         responsePayload = {
            status: 'not_found', // Indica que não achou dados, não necessariamente um erro
            message: 'Nenhum registro de cliente encontrado para este Google ID (planilha vazia ou sem dados).',
            googleUserId: googleIdToSearch
        };
         // Retorna imediatamente neste caso, não é um erro fatal para doGet
         return responsePayload; // Retorna o payload para a função chamadora (doGet principal)
    }
    headers = data[0].map(header => String(header).trim()); // Cabeçalhos

    // 4. Encontra o índice da coluna do Google ID na aba de clientes
    const googleIdColumnIndex = headers.indexOf(GOOGLE_ID_COLUMN_NAME_CLIENTES);
    if (googleIdColumnIndex === -1) {
      throw new Error(`Coluna "${GOOGLE_ID_COLUMN_NAME_CLIENTES}" não encontrada nos cabeçalhos da aba "${SHEET_NAME_CLIENTES}": [${headers.join(', ')}]`);
    }

    // 5. Procura pela linha que corresponde ao Google ID
    let foundRowData = null;
    let foundRowIndex = -1; // Para log
    // Começa do índice 1 para pular o cabeçalho
    for (let i = 1; i < data.length; i++) {
      // Compara o valor na coluna do Google ID com o ID buscado
      if (String(data[i][googleIdColumnIndex]).trim() === String(googleIdToSearch).trim()) {
        foundRowData = data[i]; // Armazena a linha inteira encontrada
        foundRowIndex = i; // Armazena o índice no array de dados (base 0)
        Logger.log(`[doGet Cliente] Linha encontrada no índice ${foundRowIndex} (linha ${foundRowIndex+1} da planilha) para o Google ID ${googleIdToSearch}.`);
        break; // Para a busca assim que encontrar a primeira correspondência
      }
    }

    // 6. Prepara a resposta
    if (foundRowData) {
      // Se encontrou a linha, mapeia os dados de volta para um objeto JSON
      const clientData = {};
      // Itera sobre o mapeamento FIELD_TO_COLUMN_MAP_CLIENTES
      for (const fieldName in FIELD_TO_COLUMN_MAP_CLIENTES) {
        const columnName = FIELD_TO_COLUMN_MAP_CLIENTES[fieldName];
        const columnIndex = headers.indexOf(columnName);
        // Se a coluna mapeada existe
        if (columnIndex !== -1) {
          // Pega o valor da célula correspondente na linha encontrada
          clientData[fieldName] = foundRowData[columnIndex];
        } else {
            Logger.log(`[doGet Cliente] Aviso: Coluna "${columnName}" mapeada para "${fieldName}" não encontrada nos cabeçalhos ao buscar dados.`);
        }
      }
       // Inclui explicitamente o googleUserId nos dados retornados
      clientData.googleUserId = googleIdToSearch;

      // Monta a resposta de sucesso com os dados do cliente
      responsePayload = {
        status: 'success',
        message: 'Dados do cliente encontrados.',
        googleUserId: googleIdToSearch, // Inclui o ID que foi buscado
        clientData: clientData // O objeto com os dados mapeados
      };
      Logger.log(`[doGet Cliente] Dados encontrados e mapeados: ${JSON.stringify(clientData)}`);
    } else {
      // Se não encontrou nenhuma linha correspondente (e a planilha não estava vazia)
      responsePayload = {
        status: 'not_found',
        message: 'Nenhum registro de cliente encontrado para este Google ID.',
        googleUserId: googleIdToSearch,
        clientData: null // Retorna null para os dados do cliente
      };
      Logger.log(`[doGet Cliente] Nenhum registro encontrado para Google ID: ${googleIdToSearch}`);
    }

  } catch (error) {
    // 7. Tratamento de erros durante a busca
    Logger.log(`[doGet Cliente] Erro: ${error.message}\nParâmetros recebidos: ${JSON.stringify(e?.parameter)}\nStack: ${error.stack}`);
    responsePayload = {
      status: 'error',
      message: `Erro ao buscar dados do cliente: ${error.message}`,
      // Incluir detalhes do erro pode ser útil para depuração, mas cuidado com informações sensíveis
      // errorDetails: error.toString()
    };
  }
  // Não há bloco finally aqui, o retorno é feito dentro do try/catch
  return responsePayload; // Retorna o payload para a função chamadora (doGet principal)
}


// ========================================================================
// FUNÇÃO doGetProductsByGogoid: Busca todos os produtos associados a um GOGOID
// Recebe o GOGOID como parâmetro na URL (e.parameter.googleUserId)
// Retorna um array de objetos com os dados dos produtos.
// Esta função é chamada pela função doGet principal.
// ========================================================================
function doGetProductsByGogoid(e) {
  let responsePayload = {}; // Objeto para a resposta JSON
  let ss, sheet, headers, data, googleIdToSearch;

  try {
    // 1. Valida se o parâmetro 'googleUserId' foi passado na URL
    if (!e || !e.parameter || !e.parameter.googleUserId) {
      // Lança erro, pois esta função específica requer googleUserId
      throw new Error("Parâmetro 'googleUserId' não fornecido na requisição GET para produtos por GOGOID.");
    }
    googleIdToSearch = e.parameter.googleUserId;
    Logger.log(`[doGet Produtos por GOGOID] Buscando produtos para Google ID: ${googleIdToSearch}`);

    // 2. Acessa a planilha e a aba de Produtos
    ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    sheet = ss.getSheetByName(SHEET_NAME_PRODUTOS); // Usa o nome da aba de produtos
    if (!sheet) {
      throw new Error(`Aba "${SHEET_NAME_PRODUTOS}" não encontrada.`);
    }

    // 3. Lê os cabeçalhos e todos os dados da planilha
    data = sheet.getDataRange().getValues();
    // Verifica se há pelo menos a linha de cabeçalho E uma linha de dados
    if (data.length < 2) {
        Logger.log(`[doGet Produtos por GOGOID] Planilha "${SHEET_NAME_PRODUTOS}" vazia ou sem dados (apenas cabeçalho).`);
         responsePayload = {
            status: 'not_found', // Indica que não achou dados, não necessariamente um erro
            message: 'Nenhum produto encontrado para este Google ID (planilha vazia ou sem dados).',
            googleUserId: googleIdToSearch,
            productsData: [] // Retorna um array vazio
        };
         // Retorna o payload para a função chamadora (doGet principal)
         return responsePayload;
    }
    headers = data[0].map(header => String(header).trim()); // Cabeçalhos

    // 4. Encontra o índice da coluna do GOGOID
    const gogoidColumnIndex = headers.indexOf(GOGOID_COLUMN_NAME);
    if (gogoidColumnIndex === -1) {
      throw new Error(`Coluna "${GOGOID_COLUMN_NAME}" não encontrada nos cabeçalhos da aba "${SHEET_NAME_PRODUTOS}": [${headers.join(', ')}]`);
    }

    // 5. Procura pelas linhas que correspondem ao GOGOID
    const foundProducts = [];
    // Começa do índice 1 para pular o cabeçalho
    for (let i = 1; i < data.length; i++) {
      // Compara o valor na coluna do GOGOID com o ID buscado
      if (String(data[i][gogoidColumnIndex]).trim() === String(googleIdToSearch).trim()) {
        // Se encontrou uma linha, mapeia os dados de volta para um objeto JSON
        const productData = {};
        // Itera sobre os cabeçalhos para criar o objeto do produto
        headers.forEach((header, index) => {
             // Adiciona todas as colunas encontradas na linha
             productData[header] = data[i][index];
        });
        foundProducts.push(productData); // Adiciona o objeto do produto ao array
        Logger.log(`[doGet Produtos por GOGOID] Produto encontrado na linha ${i+1} para o Google ID ${googleIdToSearch}.`);
      }
    }

    // 6. Prepara a resposta
    if (foundProducts.length > 0) {
      // Se encontrou produtos
      responsePayload = {
        status: 'success',
        message: `${foundProducts.length} produto(s) encontrado(s).`,
        googleUserId: googleIdToSearch, // Inclui o ID que foi buscado
        productsData: foundProducts // O array com os objetos dos produtos
      };
      Logger.log(`[doGet Produtos por GOGOID] Produtos encontrados e mapeados: ${JSON.stringify(foundProducts)}`);
    } else {
      // Se não encontrou nenhuma linha correspondente (e a planilha não estava vazia)
      responsePayload = {
        status: 'not_found',
        message: 'Nenhum produto encontrado para este Google ID.',
        googleUserId: googleIdToSearch,
        productsData: [] // Retorna um array vazio
      };
      Logger.log(`[doGet Produtos por GOGOID] Nenhum produto encontrado para Google ID: ${googleIdToSearch}`);
    }

  } catch (error) {
    // 7. Tratamento de erros durante a busca
    Logger.log(`[doGet Produtos por GOGOID] Erro: ${error.message}\nParâmetros recebidos: ${JSON.stringify(e?.parameter)}\nStack: ${error.stack}`);
    responsePayload = {
      status: 'error',
      message: `Erro ao buscar produtos: ${error.message}`,
      // Incluir detalhes do erro pode ser útil para depuração, mas cuidado com informações sensíveis
      // errorDetails: error.toString()
    };
  }
  // Não há bloco finally aqui, o retorno é feito dentro do try/catch
  return responsePayload; // Retorna o payload para a função chamadora (doGet principal)
}


// ========================================================================
// NOVA FUNÇÃO doGetProductById: Busca um produto específico pelo ID_PRODUTO
// Recebe o ID_PRODUTO como parâmetro na URL (e.parameter.productId)
// Retorna um objeto com os dados do produto encontrado.
// Esta função é chamada pela função doGet principal.
// ========================================================================
function doGetProductById(e) {
  let responsePayload = {}; // Objeto para a resposta JSON
  let ss, sheet, headers, data, productIdToSearch;

  try {
    // 1. Valida se o parâmetro 'productId' foi passado na URL
    if (!e || !e.parameter || !e.parameter.productId) {
      // Lança erro, pois esta função específica requer productId
      throw new Error("Parâmetro 'productId' não fornecido na requisição GET para produto por ID.");
    }
    productIdToSearch = e.parameter.productId;
    Logger.log(`[doGet Produto por ID] Buscando produto pelo ID: ${productIdToSearch}`);

    // 2. Acessa a planilha e a aba de Produtos
    ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    sheet = ss.getSheetByName(SHEET_NAME_PRODUTOS); // Usa o nome da aba de produtos
    if (!sheet) {
      throw new Error(`Aba "${SHEET_NAME_PRODUTOS}" não encontrada.`);
    }

    // 3. Lê os cabeçalhos e todos os dados da planilha
    data = sheet.getDataRange().getValues();
    // Verifica se há pelo menos a linha de cabeçalho E uma linha de dados
    if (data.length < 2) {
         Logger.log(`[doGet Produto por ID] Planilha "${SHEET_NAME_PRODUTOS}" vazia ou sem dados (apenas cabeçalho).`);
         responsePayload = {
            status: 'not_found', // Indica que não achou dados, não necessariamente um erro
            message: 'Nenhum produto encontrado com este ID (planilha vazia ou sem dados).',
            productId: productIdToSearch,
            productData: null // Retorna null para os dados do produto
        };
         // Retorna o payload para a função chamadora (doGet principal)
         return responsePayload;
    }
    headers = data[0].map(header => String(header).trim()); // Cabeçalhos

    // 4. Encontra o índice da coluna do ID_PRODUTO
    const productIdColumnIndex = headers.indexOf(PRODUCT_ID_COLUMN_NAME);
    if (productIdColumnIndex === -1) {
      throw new Error(`Coluna "${PRODUCT_ID_COLUMN_NAME}" não encontrada nos cabeçalhos da aba "${SHEET_NAME_PRODUTOS}": [${headers.join(', ')}]`);
    }

    // 5. Procura pela linha que corresponde ao ID_PRODUTO
    let foundProductData = null;
    // Começa do índice 1 para pular o cabeçalho
    for (let i = 1; i < data.length; i++) {
      // Compara o valor na coluna do ID_PRODUTO com o ID buscado
      if (String(data[i][productIdColumnIndex]).trim() === String(productIdToSearch).trim()) {
        // Se encontrou a linha, mapeia os dados de volta para um objeto JSON
        const productData = {};
        // Itera sobre os cabeçalhos para criar o objeto do produto
        headers.forEach((header, index) => {
             // Adiciona todas as colunas encontradas na linha
             productData[header] = data[i][index];
        });
        foundProductData = productData; // Armazena o objeto do produto encontrado
        Logger.log(`[doGet Produto por ID] Produto encontrado na linha ${i+1} para o ID ${productIdToSearch}.`);
        break; // Para a busca assim que encontrar a primeira correspondência
      }
    }

    // 6. Prepara a resposta
    if (foundProductData) {
      // Se encontrou o produto
      responsePayload = {
        status: 'success',
        message: 'Produto encontrado.',
        productId: productIdToSearch, // Inclui o ID que foi buscado
        productData: foundProductData // O objeto com os dados do produto
      };
      Logger.log(`[doGet Produto por ID] Dados do produto encontrados e mapeados: ${JSON.stringify(foundProductData)}`);
    } else {
      // Se não encontrou nenhuma linha correspondente (e a planilha não estava vazia)
      responsePayload = {
        status: 'not_found',
        message: 'Nenhum produto encontrado com este ID.',
        productId: productIdToSearch,
        productData: null // Retorna null para os dados do produto
      };
      Logger.log(`[doGet Produto por ID] Nenhum produto encontrado para ID: ${productIdToSearch}`);
    }

  } catch (error) {
    // 7. Tratamento de erros durante a busca
    Logger.log(`[doGet Produto por ID] Erro: ${error.message}\nParâmetros recebidos: ${JSON.stringify(e?.parameter)}\nStack: ${error.stack}`);
    responsePayload = {
      status: 'error',
      message: `Erro ao buscar produto: ${error.message}`,
      // Incluir detalhes do erro pode ser útil para depuração, mas cuidado com informações sensíveis
      // errorDetails: error.toString()
    };
  }
  // Não há bloco finally aqui, o retorno é feito dentro do try/catch
  return responsePayload; // Retorna o payload para a função chamadora (doGet principal)
}
// ========================================================================
// NOVA FUNÇÃO para carregar produtos de uma loja específica (por GOGOID):
// Acessa a aba "Loja"
// // Busca dados da loja
// Busca produtos em massa (eficiente)
// Chamada via URL (GET):https://script.google.com/.../exec?action=getProdutosDaLoja&gogoid=LOJA_123
// ========================================================================
function doGetProdutosDaLoja(e) {
  // Inicializa o objeto de resposta padrão.
  const response = { status: 'error', message: 'Erro desconhecido ao buscar produtos da loja.', data: null };
  const gogoid = e?.parameter?.gogoid; // gogoid da LOJA
  
  Logger.log(`[doGetProdutosDaLoja] Iniciando. gogoid da loja recebido: "${gogoid}"`);

  try {
    if (!gogoid) {
      response.message = "Parâmetro 'gogoid' da loja é obrigatório.";
      Logger.log(`[doGetProdutosDaLoja] Erro: ${response.message}`);
      // Retorna imediatamente se o gogoid não for fornecido.
      return ContentService.createTextOutput(JSON.stringify(response))
                        .setMimeType(ContentService.MimeType.JSON);
    }

    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);

    // 1. Acessar a aba "Loja" e encontrar a loja
    const sheetLoja = ss.getSheetByName(SHEET_NAME_LOJA);
    if (!sheetLoja) {
      response.message = `Aba "${SHEET_NAME_LOJA}" não encontrada.`;
      Logger.log(`[doGetProdutosDaLoja] Erro: ${response.message}`);
      throw new Error(response.message); // Lança para ser pego pelo catch externo e logado
    }
    Logger.log(`[doGetProdutosDaLoja] Aba "${SHEET_NAME_LOJA}" acessada.`);

    const lojaHeaders = getHeaders(sheetLoja); // Pode lançar erro se planilha Loja estiver vazia
    const lojaGogoidIndex = lojaHeaders.indexOf(LOJA_GOGOID_COLUMN_NAME); // 'ID'
    const lojaProdutosIdsIndex = lojaHeaders.indexOf(LOJA_PRODUTOS_COLUMN_NAME); // 'Produtos Da Loja'
    const lojaNomeIndex = lojaHeaders.indexOf(LOJA_NAME_COLUMN_NAME); // 'loja'

    Logger.log(`[doGetProdutosDaLoja] Cabeçalhos da Aba Loja: [${lojaHeaders.join(', ')}]`);
    Logger.log(`[doGetProdutosDaLoja] Índices na Aba Loja - gogoid: ${lojaGogoidIndex}, produtosIds: ${lojaProdutosIdsIndex}, nomeLoja: ${lojaNomeIndex}`);

    if (lojaGogoidIndex === -1 || lojaProdutosIdsIndex === -1 || lojaNomeIndex === -1) {
      let missing = [];
      if(lojaGogoidIndex === -1) missing.push(LOJA_GOGOID_COLUMN_NAME);
      if(lojaProdutosIdsIndex === -1) missing.push(LOJA_PRODUTOS_COLUMN_NAME);
      if(lojaNomeIndex === -1) missing.push(LOJA_NAME_COLUMN_NAME);
      response.message = `Colunas essenciais (${missing.join(', ')}) faltando na aba "${SHEET_NAME_LOJA}".`;
      Logger.log(`[doGetProdutosDaLoja] Erro: ${response.message}`);
      throw new Error(response.message);
    }

    const todasLojasData = sheetLoja.getDataRange().getValues();
    let lojaInfo = null;
    Logger.log(`[doGetProdutosDaLoja] Procurando loja com gogoid "${gogoid}" em ${todasLojasData.length -1} registros da aba Loja.`);

    for (let i = 1; i < todasLojasData.length; i++) { // Começa de 1 para pular cabeçalho
      const currentRowGogoid = String(todasLojasData[i][lojaGogoidIndex]).trim();
      if (currentRowGogoid === gogoid) {
        const nomeDaLoja = String(todasLojasData[i][lojaNomeIndex]).trim();
        const produtosIdsString = todasLojasData[i][lojaProdutosIdsIndex] ? String(todasLojasData[i][lojaProdutosIdsIndex]).trim() : "";
        
        Logger.log(`[doGetProdutosDaLoja] Loja encontrada na linha ${i+1}: Nome="${nomeDaLoja}", GOGOID="${currentRowGogoid}", ProdutosIDs (string)="${produtosIdsString}"`);
        
        lojaInfo = {
          nome: nomeDaLoja,
          // Divide a string de IDs, remove espaços e filtra IDs vazios
          produtosIds: produtosIdsString.split(',').map(id => id.trim()).filter(id => id !== "")
        };
        Logger.log(`[doGetProdutosDaLoja] Loja Info Processada: Nome="${lojaInfo.nome}", IDs de Produto (array): [${lojaInfo.produtosIds.join(',')}]`);
        break;
      }
    }

    if (!lojaInfo) {
      response.status = 'not_found';
      response.message = `Loja com gogoid "${gogoid}" não encontrada.`;
      Logger.log(`[doGetProdutosDaLoja] ${response.message}`);
      // Retorna uma resposta JSON controlada, não lança exceção.
      return ContentService.createTextOutput(JSON.stringify(response))
                        .setMimeType(ContentService.MimeType.JSON);
    }
    
    if (!lojaInfo.nome) {
        response.status = 'warning'; // Ou 'error', dependendo da criticidade
        response.message = `Loja com gogoid "${gogoid}" encontrada, mas não possui um nome definido na planilha.`;
        Logger.log(`[doGetProdutosDaLoja] Aviso: ${response.message}`);
        // Decide se continua ou retorna. Por ora, continua mas loga.
    }

    if (lojaInfo.produtosIds.length === 0) {
      response.status = 'success'; // Sucesso, mas a loja não tem produtos listados.
      response.message = `Loja "${lojaInfo.nome}" encontrada, mas não possui produtos associados na lista.`;
      response.data = { loja: lojaInfo.nome, produtos: [] };
      Logger.log(`[doGetProdutosDaLoja] ${response.message}`);
      return ContentService.createTextOutput(JSON.stringify(response))
                        .setMimeType(ContentService.MimeType.JSON);
    }

    Logger.log(`[doGetProdutosDaLoja] IDs de produto a serem buscados para a loja "${lojaInfo.nome}": [${lojaInfo.produtosIds.join(',')}]`);

    // 2. Acessar a aba "Produtos" e buscar os produtos pelos IDs
    const sheetProdutos = ss.getSheetByName(SHEET_NAME_PRODUTOS);
    if (!sheetProdutos) {
      response.message = `Aba "${SHEET_NAME_PRODUTOS}" não encontrada.`;
      Logger.log(`[doGetProdutosDaLoja] Erro: ${response.message}`);
      throw new Error(response.message);
    }
    Logger.log(`[doGetProdutosDaLoja] Aba "${SHEET_NAME_PRODUTOS}" acessada.`);

    const produtosHeaders = getHeaders(sheetProdutos); // Pode lançar erro se planilha Produtos estiver vazia
    const produtoIdPlanilhaIndex = produtosHeaders.indexOf(PRODUCT_ID_COLUMN_NAME); // 'ID_PRODUTO'

    Logger.log(`[doGetProdutosDaLoja] Cabeçalhos da Aba Produtos: [${produtosHeaders.join(', ')}]`);
    Logger.log(`[doGetProdutosDaLoja] Índice da coluna ID_PRODUTO na Aba Produtos: ${produtoIdPlanilhaIndex}`);

    if (produtoIdPlanilhaIndex === -1) {
      response.message = `Coluna "${PRODUCT_ID_COLUMN_NAME}" faltando na aba "${SHEET_NAME_PRODUTOS}".`;
      Logger.log(`[doGetProdutosDaLoja] Erro: ${response.message}`);
      throw new Error(response.message);
    }

    const todosProdutosData = sheetProdutos.getDataRange().getValues();
    const produtosEncontradosParaLoja = [];
    Logger.log(`[doGetProdutosDaLoja] Buscando ${lojaInfo.produtosIds.length} IDs de produto na aba "${SHEET_NAME_PRODUTOS}" (${todosProdutosData.length -1} registros).`);

    for (let i = 1; i < todosProdutosData.length; i++) { // Ignora cabeçalho
      const produtoRow = todosProdutosData[i];
      const produtoIdNaPlanilha = String(produtoRow[produtoIdPlanilhaIndex]).trim();
      
      // Logger.log(`[doGetProdutosDaLoja] Verificando produto na linha ${i+1} da aba Produtos: ID="${produtoIdNaPlanilha}"`);
      if (lojaInfo.produtosIds.includes(produtoIdNaPlanilha)) {
        const produtoObj = rowToObject(produtoRow, produtosHeaders);
        produtosEncontradosParaLoja.push(produtoObj);
        Logger.log(`[doGetProdutosDaLoja] Produto Encontrado e Adicionado: ID="${produtoIdNaPlanilha}", Nome="${produtoObj.NOME || 'N/A'}"`);
      }
    }
    Logger.log(`[doGetProdutosDaLoja] Total de ${produtosEncontradosParaLoja.length} produtos encontrados para a loja "${lojaInfo.nome}".`);

    response.status = 'success';
    response.message = produtosEncontradosParaLoja.length > 0 ? `Produtos da loja "${lojaInfo.nome}" carregados.` : `Loja "${lojaInfo.nome}" encontrada, mas nenhum dos produtos listados (${lojaInfo.produtosIds.join(',')}) foi encontrado na aba "${SHEET_NAME_PRODUTOS}".`;
    response.data = {
      loja: lojaInfo.nome,
      produtos: produtosEncontradosParaLoja
    };
    Logger.log(`[doGetProdutosDaLoja] Resposta final: Status="${response.status}", Mensagem="${response.message}", Número de Produtos Retornados=${produtosEncontradosParaLoja.length}`);

  } catch (error) {
    // Este catch lida com erros inesperados ou aqueles lançados explicitamente.
    Logger.log(`[doGetProdutosDaLoja] ERRO CAPTURADO NA FUNÇÃO: ${error.message}\nStack: ${error.stack}`);
    // Garante que a resposta mantenha a estrutura esperada em caso de erro.
    response.status = 'error'; 
    response.message = `Erro interno ao processar produtos da loja: ${error.message}`;
    response.data = null; 
  }
  
  // Sempre retorna um ContentService output com JSON.
  // Logger.log(`[doGetProdutosDaLoja] Retornando JSON: ${JSON.stringify(response)}`); // Cuidado com logs muito grandes
  return ContentService.createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON);
}
// ========================================================================
// NOVA Função para carregar TODOS os produtos ordenados por reputação da loja:
// Busca todas as lojas ordenadas por reputação
// Busca todos os produtos de uma vez (eficiente)
// Busca produtos em massa (eficiente)
// Chamada via URL (GET):https://script.google.com/.../exec?action=getTodosProdutosOrdenados
// ========================================================================
function doGetTodosProdutosOrdenadosPorReputacao() {
  const response = { status: 'error', message: '', data: [] };
  try {
    // Acessa abas
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheetLoja = ss.getSheetByName(SHEET_NAME_LOJA);
    const sheetProdutos = ss.getSheetByName(SHEET_NAME_PRODUTOS);
    if (!sheetLoja || !sheetProdutos) throw new Error("Planilhas não encontradas");

    // Busca todas as lojas ordenadas por reputação
    const lojaHeaders = getHeaders(sheetLoja);
    const reputacaoIndex = lojaHeaders.indexOf(LOJA_REPUTACAO_COLUMN_NAME);
    const lojaData = sheetLoja.getDataRange().getValues()
      .slice(1) // Remove cabeçalho
      .sort((a, b) => b[reputacaoIndex] - a[reputacaoIndex]); // Ordena DESC

    // Busca todos os produtos de uma vez (eficiente)
    const produtosHeaders = getHeaders(sheetProdutos);
    const produtosData = sheetProdutos.getDataRange().getValues()
      .slice(1) // Remove cabeçalho
      .map(row => rowToObject(row, produtosHeaders));

    // Mapeia produtos por ID para busca rápida
    const produtosMap = new Map();
    for (const produto of produtosData) {
      produtosMap.set(produto[PRODUCT_ID_COLUMN_NAME], produto);
    }

    // Monta resposta ordenada
    for (const lojaRow of lojaData) {
      const produtosIds = lojaRow[lojaHeaders.indexOf(LOJA_PRODUTOS_COLUMN_NAME)]?.split(',') || [];
      const produtosDaLoja = produtosIds
        .map(id => produtosMap.get(id.trim()))
        .filter(p => p !== undefined); // Remove IDs inválidos

      if (produtosDaLoja.length > 0) {
        response.data.push({
          loja: lojaRow[lojaHeaders.indexOf(LOJA_NAME_COLUMN_NAME)],
          reputacao: lojaRow[reputacaoIndex],
          produtos: produtosDaLoja
        });
      }
    }

    response.status = 'success';

  } catch (error) {
    response.message = error.message;
    Logger.log(`[doGetTodosProdutosOrdenadosPorReputacao] Erro: ${error.message}`);
  }
  return ContentService.createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON);
}
